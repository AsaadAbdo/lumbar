<!DOCTYPE html><html>  <head>    <meta http-equiv="content-type" content="text/html;charset=UTF-8">
    <meta http-equiv="X-UA-Compatible" content="chrome=1">
    <title>Lumbar Plugins</title>
    <script type="text/javascript" src="scripts/main.js"></script>
    <script type="text/javascript" src="scripts/whitespace.js"></script>
    <link rel="stylesheet" href="styles/main.css">
    <link rel="stylesheet" href="styles/style.css">
</head>
  <body>    <div id="sidebar" class="interface">
      <h2>
        <a href="#plugin">Plugin Points</a>
      </h2>
      <ul>
        <li>
          <a href="#plugin points-moduleresources(context,">moduleResources(context, next)</a>
        </li>
        <li>
          <a href="#plugin points-resourcelist(context,">resourceList(context, next)</a>
        </li>
        <li>
          <a href="#plugin points-file(context,">file(context, next)</a>
        </li>
        <li>
          <a href="#plugin points-module(context,">module(context, next)</a>
        </li>
        <li>
          <a href="#plugin points-resource(context,">resource(context, msg)</a>
        </li>
      </ul>
      <h2>
        <a href="#context">Context</a>
      </h2>
      <ul>
        <li>
          <a href="#context-caches">Caches</a>
        </li>
      </ul>
      <h2>
        <a href="#warnings">Warnings</a>
      </h2>
    </div>
    <div class="container">      <h1>Plugins</h1>
      <p>Lumbar may be extended through plugins that can inject or modify the behavior at numerous different
places in the build process.</p>
      <h2 id="plugin">Plugin Points</h2>
      <p>Plugins primary method of interaction with Lumbar it through the         <code>moduleResources</code>
,         <code>resourceList</code>
,
        <code>file</code>
,         <code>module</code>
, and         <code>resource</code>
 callbacks. Each of these callbacks are implemented as a chain,
allowing for a plugin to modify the current context object and determine if subsequent plugins are
allowed to operate, via the         <code>next</code>
 parameter passed to the callback.</p>
      <h3 id="plugin points-moduleresources(context,">moduleResources(context, next)</h3>
      <p>Called when generating a list of all resources that a given module will need. This method may be
used to add additional content to the module one time such as the router declaration for router
modules.</p>
      <p>This callback is called when generating the         <code>moduleResources</code>
 list and has access to the
        <code>module</code>
,         <code>platformPath</code>
,         <code>options</code>
,         <code>config</code>
,         <code>configCache</code>
,         <code>fileCache</code>
, and         <code>moduleCache</code>

context fields. It should return a list of resource objects.</p>
      <p>Example from the router plugin:</p>
      <p>
        <code></code>
` javascript 
moduleResources: function(context, next) {
    var ret = next();</p>
      <pre>
        <code>// Generate the router if we have the info for it
var module = context.module;
if (module.routes) {
    ret.unshift({ routes: module.routes });
}

return ret;</code>
      </pre>
      <p>}
        <code></code>
`</p>
      <h3 id="plugin points-resourcelist(context,">resourceList(context, next)</h3>
      <p>Allows plugins to create multiple resources from a single resource. Called once for each
resource generated from the         <code>moduleResources</code>
 callback. Returns an array of resources.
Resources may be any object the plugin wishes. Strings will be treated as file or directory
includes as will object that define a         <code>src</code>
 field. Resources that define a         <code>platform</code>
 or
        <code>platforms</code>
 fields will be filtered based on the current platform settings.</p>
      <p>Example from the scope plugin:</p>
      <p>
        <code></code>
` javascript 
resourceList: function(context, next) {
    var resources = next();
    if (context.config.attributes.scope === 'resource' &amp;&amp; 
        !context.resource.global) {</p>
      <pre>
        <code>    resources.unshift(generator('(function() {\n'));
    resources.push(generator('}).call(this);\n'));
}
return resources;</code>
      </pre>
      <p>}
        <code></code>
`</p>
      <h3 id="plugin points-file(context,">file(context, next)</h3>
      <p>Allows plugins to apply file-level changes to the resources. Called once for each file
generated, just prior to resources being combined. May alter the         <code>context.resources</code>
 field
to change the resource list.</p>
      <h3 id="plugin points-module(context,">module(context, next)</h3>
      <p>Allow plugins to apply module-level changes to the resources. Called once for each module.
May alter the resource list associated with the module by altering the         <code>context.moduleResources</code>

field.</p>
      <h3 id="plugin points-resource(context,">resource(context, msg)</h3>
      <p>Allows plugins to include content other than direct file references. Called once per each resource
to be included in the output. Should return a function accepting one         <code>callback(err, data)</code>
 parameter.
On execution the function should take any steps needed to generate the resource's content and call
the callback on completion or error.</p>
      <p>
        <code>data</code>
 may be a         <code>String</code>
,         <code>Buffer</code>
, or object defining a         <code>data</code>
 field whose value is a         <code>String</code>
 or
        <code>Buffer</code>
.</p>
      <p>If the content of the resource is directly associated with a source file or files the function may
define a         <code>sourceFile</code>
 field which will be watched in watch mode and trigger a rebuild if it changed.
If multiple files are needed or are not known until execution time, the returned         <code>data</code>
 object may
define an         <code>inputs</code>
 field containing an array of the files that should be watched.</p>
      <p>The         <code>data</code>
 object may also specify a         <code>noSeparator</code>
 field, which if truthy will prevent the combiner
logic from emitting a separator after this content. Resources that always end in a complete statement
should utilize this field.</p>
      <h2 id="context">Context</h2>
      <p>Each plugin method is passed a         <code>context</code>
 parameter which describes the entire state of the build
at the point of the call. Plugins are free to modify this structure as they please.</p>
      <ul>
        <li>
          <strong>package</strong>
 : The name of the package currently being operated on.</li>
        <li>
          <strong>platform</strong>
 : The name of the platform currently being operated on.</li>
        <li>
          <strong>module</strong>
 : The module currently being operated on, as defined in the JSON file.</li>
        <li>
          <strong>resource</strong>
 : The resource currently being operated on, if applicable. Definition depends on plugins.</li>
        <li>
          <strong>moduleResources</strong>
 : All resources associated with the current module, if available.</li>
        <li>
          <strong>resources</strong>
 : All resources associated with a file. For non-combined cases this is identical to           <code>moduleResources</code>
        </li>
        <li>
          <strong>platformPath</strong>
 : Path to the output path for the current platform</li>
        <li>
          <strong>options</strong>
 : Options passed to the lumbar initialize call</li>
        <li>
          <strong>config</strong>
 : Current lumbar configuration. See           <em>config.js</em>
        </li>
        <li>
          <strong>combined</strong>
 : Truthy if the output content is intended to be combined when possible</li>
      </ul>
      <h3 id="context-caches">Caches</h3>
      <p>Each context object defines a variety of caches that are reset at specific points through the
build process. This allows plugins to cache any relevant data for specific timeframes. Note
that these objects are shared across all plugins so proper naming conventions should be followed
to prevent conflicts.</p>
      <ul>
        <li>
          <strong>configCache</strong>
 : Reset when the configuration file changes</li>
        <li>
          <strong>fileCache</strong>
 : Reset when the current file processing completes</li>
        <li>
          <strong>moduleCache</strong>
 : Reset when the current module processing completes</li>
      </ul>
      <h2 id="warnings">Warnings</h2>
      <p>As most Lumbar projects are dealing with a large number of files it is quite susceptible to
        <strong>EMFILE</strong>
 exceptions under OSX. The current recovery method for this is to utilize async
methods and retry methods that fail due to this error. A variety of file methods that are
protected from this case have been made available on the         <code>lumbar.fileUtil</code>
 object. It
is recommended that these methods are used whenever possible while dealing with files throughout
the system.</p>
      <p>TODO : Document the fileUtils APIs.
TODO : Discuss the file read cache.</p>
</div>
</body>
</html>
